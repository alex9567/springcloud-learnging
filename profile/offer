1.题目：二维数组种的查找，在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
（1，2，3）
（4，5，6）
（7，8，9）
解答：
方法1，二分发循环查找
方法2，直接从第一行的最后一个开始找，大就向下，小就向左

2.题目：替换空格，请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
解答：
方法1，replace函数（不推荐）
方法2，用空格split,然后循环拼接
方法3，直接在当前字符串从前向后替换
方法四，先计算替换后的字符串需要多大的空间，并对原字符串空间进行扩容；
从后往前替换字符串的话，每个字符串只需要移动一次；
如果从前往后，每个字符串需要多次移动，效率较低。

3.题目：从头到尾打印链表，输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
解答：
方法1，借助于栈：我们从头到尾遍历链表，可以把遍历的结果放入栈中（先进后出），这样输出栈就实现了从尾到头输出链表元素。有额外的空间消耗
方法2，翻转链表再打印，没有空间消耗但是破坏链表结构（头插法，头部空出来，反转。或者从尾部开始新的一个，开始反转）
方法3，递归，栈也是递归的思路

4.题目：重建二叉树，输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
解答：
方法1
先序遍历第一个位置肯定是根节点node，
中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组 
另一方面，先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组
把四个数组找出来，分左右递归调用即可

5.题目：用两个栈实现队列，用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
解答：
方法1，队列（表的前端进行删除操作，而在表的后端进行插入操作）
A栈插入，然后如果要删除，就A栈倒入B栈，然后删除，如果还要插入，就再次倒入A栈，再次插入

6.题目：旋转数组的最小数字，把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
解答：
方法1，直接遍历，找到最小值
方法2，由于旋转后，前面是一个递增子序列，后面是一个递增子序列，找出不是递增的那个元素
方法3，二分法

7.题目：斐波那契数列，大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
解答：
F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*），判断0，1，从2开始

8.题目：跳台阶，一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
解答：
递推公式：F（n）=F（n-1）+F（n-2），是个斐波那契数列，这个鬼答案本身就是这个斐波那契数列，
方法1：自底向上，使用迭代
方法2：自顶向下，使用递归

9.题目：变态跳台阶，一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
解答：
递推公式：f(n) = 2*f(n-1)
方法1：自底向上，使用迭代
方法2：自顶向下，使用递归

10.题目：矩形覆盖，我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
解答：
递推公式：F（n）=F（n-1）+F（n-2），是个斐波那契数列，这个鬼答案本身就是这个斐波那契数列，
方法1：自底向上，使用迭代
方法2：自顶向下，使用递归

11.题目：二进制中1的个数，输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
解答：
方法1，转为string，判断有多少个1
方法2，java中的int类型用32位表示，把这个数依次无符号右移（考虑到负数所以选择无符号右移）然后与1作与运算。如果结果为1则count自增
if((n >>> i & 1) == 1)++count;
方法3，将n与n-1想与会把n的最右边的1去掉，再让count++即可计算出有多少个1
方法4,        
if ((n & flag) != 0)count++;
flag=flag << 1;

12.题目：数值的整数次方，给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0
解答：
方法1，直接累乘（✖️）
方法2，写出指数的二进制表达，例如13表达为二进制1101。 通过&1和>>1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。举例:10^1101 = 10^0001*10^0100*10^1000

13.题目：调整数组顺序使奇书位于偶数前面，输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
解答：
方法1，队列中添加两个指针a,b。其中a是下一个奇数位所要放置的位置，b指针用来遍历队列。
判断b指向元素是否为奇数，如果不是b后移一位继续判断是否为奇数，如果是奇数，则将a与b之间的元素后移一位，并将b原来的值插入a处，同时将a指针后移一位。
方法2，重新定义一个相同大小数组，遍历第一个数组，同时从两端进行判断，从左边的只负责判断奇数，遇到就放入新数组（正向放入）；从右边的只负责判断偶数，遇到就放入新数组（后从向前放），一遍循环结束，
方法3，插排
方法4，冒泡排
方法5，快排不稳定，不适用于这道题
方法6，新建一个数组，空间换时间

14.题目：链表中倒数第k个节点，输入一个链表，输出该链表中倒数第k个结点。
解答：
考虑链表的长度是否大于k
方法1，直接压入栈中，先进后出，再出倒k即可
方法2，双指针，a，b，a先走到k点,再一起向后走，碰到尾部，这时b指针即是k的位置

15.题目：反转链表，输入一个链表，反转链表后，输出新链表的表头。
解答：
考虑空链表的情况
方法1，直接压入栈中，先进后出
方法2，递归法反转链表，总体来说，递归法是从最后一个Node开始，在弹栈的过程中将指针顺序置换的。
方法3，遍历法就是在链表遍历的过程中将指针顺序置换
